
General Plan:
	We first must get the router address and see if we are on the right router (How would we do this? Could we get the router's MAC address, or other ID? We could use pub IP, but IP can change. Or maybe we don't do this entirely). Then, we try to connect to our list of hosts on the network (by hostname? Do we just hardcode the device IP even though we're probably using DHCP (we can also hardcode it in the router settings)?). We do a little unique greeting of sorts just to make sure the applications are the same. We then issue each (online) host a challenge, perhaps to sign a hash/something random, and they reply back with the signed hash. They will then do the same with us, and we will have to sign one hash for each host. If *** o n e *** host fails/ignores the challenge, we terminate the connection with ***every*** one (This is a secure, private system on a private network. There is no chance that any one of the hosts, given this, would fail the challenge). After we verify everyone, we then combine our keys into one mega key and share a secret AES key (or equivalent symmetric cipher) amongst all of us. Then, we (all of the hosts collectively) generate **new** key pairs and use the shared secret to share the public keys with each other (really we don't need to do this often, and we should probably wait until all of the hosts are online so that there are not any outdated key issues). This way, the attacker doesn't even know the public keys, but all relevant parties know the public keys of each other. We can also, for whatever reason, do a key refresh in the middle of a connection. If any hosts are not connected to the server, they will be dropped out of the loop until they are added again. This can effectively delete hosts, and we can also add a host with a command to add given an address (tbd what parameters this will take). When we add a host, the host that issued the command will connect to the new hosts, ask for a public key, and then disconnect. Then, the command host will issue the public key and address to all other hosts. Once everyone verifies they have it, all hosts will disconnect and the whole network will essentially reboot: disconnecting, reconnecting, initiating the handshakes, and everything else. Note that there will be a mandatory key reset after adding a host, so all desired hosts should be online when adding a new host.

	Above the security layer, we have the transfer layer. The transfer layer is a little more nuanced in the fact that it's a host by host basis. There will be a share command, where you can share a file or a folder with another host, multiple hosts, or all (connected) hosts. You can of course stop sharing too, in which case there will be no future updates sent. Every time a file is updated, there is an update request sent to the desired hosts, which will then presumably update their files. This will happen 200 ms after the event, and if a lot of files are changed in a short period of time, it will happen once every 200 ms. Also, after the handshake business, every host that has files shared with it will send a modified request, which is essentially seeing whether the file is modified. Whichever host has the latest version (latest date modified) will be the current version and all others will take from that one, but they need to compare with each other to establish that. We're also just going to trust the date on the file, so if anything edits that date for any reason, that will be the date used. Since this is meant to synchronize personal files and not things like logs, this should be absolutely fine unless the user manually modifies dates for some reason. Also, when we share an update with a host, a 'link' is formed, so either host can now update the file. If you share this with more hosts, more hosts will be added to the link. A host can also request a file/folder that is present on another host, and the same thing happens (except if the file doesn't exist, in which case an error msg is sent back). There can also be one-way modification where one host can update others, but others cannot update the one. There can also be more than one modifier and many readers. I think I will implement this by adding a field to each host in the link that states permissions for each host (read or read-write). There also will probably be a modify privledge, which would give a host authority to change permissions of other blocks. For obvious reasons, hosts cannot request any files or directories that include the config file, but hosts can share their files no problem.

1: open a file (check)
2: send a buffer over a TCP connection (check)
3: send and receive a file over TCP (kinda check)
4: implement a p2p layer (in one application) where anyone can connect and send each other files
4.1: Implement the link config file
4.2: Implement p2p
4.3: Get the commands working basically (should be decently easy given file sending would be complete).
4.4: Implement permissions and the 200ms timer.
6: implement security
